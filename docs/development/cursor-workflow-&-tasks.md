# Cursor Workflow & Tasks

*   **Project:** Vishnu Mandir, Tampa
*   **Document Type:** Cursor Workflow & Tasks
*   **Category:** Development
*   **Purpose:** To establish essential configuration and standardized workflows for AI-assisted development using the Cursor IDE. This document ensures all developers leverage AI effectively, maintain code quality, and align with project architecture and goals.

---

## 1. Overview

This document outlines the standard operating procedures for using the Cursor IDE on the Vishnu Mandir project. By embedding our project's context, architectural decisions, and coding standards directly into the IDE via a `.cursorrules` file, we can significantly accelerate development, improve code consistency, and reduce the cognitive load on developers.

The primary goal is to use AI as a highly-informed pair programmer that understands our specific needsâ€”from the Next.js frontend with Tailwind CSS to the Node.js/Prisma backend and AWS Amplify deployment target. Adhering to this workflow is mandatory for all development tasks.

## 2. Core Principles for AI-Assisted Development

1.  **Prime the AI:** Always provide context. Use Cursor's `@` symbol to reference specific files (`@/prisma/schema.prisma`, `@/components/ui/Button.tsx`) or documentation (`@.cursorrules`) before making a request.
2.  **Trust but Verify:** AI-generated code is a first draft, not a final product. Always review, understand, and test every line of code generated by the AI. You are ultimately responsible for the code you commit.
3.  **Think in Atomic Tasks:** Break down complex features into small, specific, and actionable requests. Instead of "Build the donation page," use a series of prompts like "Create a new Next.js page component at `app/donate/page.tsx`," followed by "Add a form to this component with fields for name, email, and donation amount," and then "Integrate the Stripe React component for payment processing."
4.  **Iterate and Refine:** Use the AI to refactor and improve existing code. Ask it to add comments, generate JSDoc, write unit tests, or optimize a function for performance.
5.  **Maintain the Changelog:** Every significant AI-assisted change (new component, refactored logic, etc.) must be logged in `changelog.md`. This creates an audit trail and helps the team understand the evolution of the codebase.

## 3. Initial Developer Setup

All developers must perform the following steps before writing any code.

### 3.1. Install Cursor

1.  Download and install the latest version of the Cursor IDE from [cursor.sh](https://cursor.sh/).
2.  Log in with your account to enable AI features.

### 3.2. Project Configuration

1.  Clone the project repository from the source control provider.
2.  Create a file named `.cursorrules` in the root directory of the project.
3.  Paste the entire contents of the `.cursorrules` template (see Section 4 below) into this file.
4.  Create a file named `changelog.md` in the root directory and initialize it (see Section 5 below).

### 3.3. Recommended VS Code Extensions

Cursor is compatible with the VS Code extension marketplace. For this project, ensure the following extensions are installed to maintain code quality and consistency:

*   **Prettier - Code formatter:** `esbenp.prettier-vscode`
*   **ESLint:** `dbaeumer.vscode-eslint`
*   **Prisma:** `Prisma.prisma`
*   **Tailwind CSS IntelliSense:** `bradlc.vscode-tailwindcss`

## 4. The `.cursorrules` File

This file is the "brain" for the AI. It provides all the necessary context about our project. Create a `.cursorrules` file in the project root and paste the following content into it. The AI will automatically reference this file for every request made within the project.

```markdown
# Vishnu Mandir, Tampa - Project Context for AI

This document contains the essential context, rules, and technical specifications for the Vishnu Mandir, Tampa website project. As an AI assistant, you must adhere to these guidelines for all code generation, refactoring, and documentation tasks.

---

## 1. Project Goals & Priority

- **Top Priority (MVP):** Serve devotees with accurate, up-to-date information (puja schedules, priest services).
- **Secondary Goals:** Drive community participation, enable self-service transactions (donations, sponsorships), and reduce admin workload.
- **Audience:** Devotees, event attendees, temple staff, donors, and volunteers.
- **Desired Feel:** Spiritual, traditional, serene, friendly, and cultural.

---

## 2. Core Technology Stack

- **Frontend:** Next.js (App Router) with TypeScript.
- **Styling:** Tailwind CSS. Do not use plain CSS, CSS Modules, or other CSS-in-JS libraries unless specified.
- **Backend:** Node.js with Express.js for specific API endpoints.
- **Database ORM:** Prisma.
- **Database:** PostgreSQL.
- **Deployment:** AWS Amplify. Code should be compatible with this environment.

---

## 3. Design System & Conventions

### Color Palette
- **Primary:** `d97706` (Golden Amber - `amber-600` in Tailwind)
- **Secondary:** `3b82f6` (Royal Blue - `blue-500` in Tailwind)
- **Accent:** `facc15` (Sunflower Yellow - `yellow-400` in Tailwind)
- **Background:** `fefce8` (Cream White - `yellow-50` in Tailwind)
- **Text:** `1f2937` (Charcoal Gray - `gray-800` in Tailwind)
- **Dark Mode Background:** `1f2937` (Charcoal Gray)
- **Dark Mode Text:** `fefce8` (Cream White)

### Layout
- **Type:** Landing page style for key pages, with clear sections.
- **Navigation:** Top navigation bar, sticky on scroll.
- **Responsive:** Mobile-first is a strict requirement. All components must be fully responsive.
- **Dark Mode:** All components must support dark mode using Tailwind's `dark:` variant.

### Component Naming
- Use PascalCase for component filenames and function names (e.g., `PujaCard.tsx`).
- Store components in `/components`. Use subdirectories for features (e.g., `/components/events/EventCalendar.tsx`, `/components/forms/DonationForm.tsx`).

---

## 4. High-Priority Features & Logic

- **Event Calendar:** Must display daily pujas, cultural events, and festivals.
- **Recurring Donations:** Use Stripe for payment processing. Create a robust workflow for setting up and managing recurring donations.
- **Puja Sponsorship Forms:** Forms should be structured, user-friendly, and trigger backend logic upon submission (e.g., save to DB, send email notifications via AWS SES).
- **User Role Management:** The backend must support role-based access control (Admin, Editor, Finance, Event Manager). Prisma schema should reflect this.
- **Backend API:** API routes should be created in `app/api/`. Use Express handlers where appropriate. All database interactions must go through Prisma.

---

## 5. Coding Rules & Best Practices

1.  **TypeScript First:** All code must be written in TypeScript with strict typing. Avoid using `any`.
2.  **Functional Components:** Use functional components with React Hooks. Do not use class components.
3.  **Environment Variables:** Never hard-code sensitive keys (Stripe API keys, database URLs). Use environment variables (`process.env.VARIABLE_NAME`).
4.  **Prisma Schema:** The single source of truth for the database schema is `/prisma/schema.prisma`. When asked to add a field or model, modify this file first and then generate the Prisma Client.
5.  **Error Handling:** All API endpoints and data-fetching functions must include robust error handling (`try...catch` blocks) and return meaningful error messages.
6.  **Accessibility (a11y):** All generated HTML and components must follow accessibility best practices. Use semantic HTML, `aria-` attributes, and ensure keyboard navigability. For example, all interactive elements like buttons and links must have clear focus states.
7.  **Comments:** Generate JSDoc comments for all non-trivial functions, API endpoints, and complex components, explaining their purpose, parameters, and return values.

By following these rules, you will help us build a high-quality, maintainable, and scalable website for the Vishnu Mandir community.
```

## 5. The `changelog.md` File

This file tracks all significant changes made with the help of AI. It provides a human-readable history of AI contributions. Create `changelog.md` in the project root with the following initial content:

```markdown
# AI-Assisted Changelog

This document tracks significant features, components, and refactors generated or assisted by Cursor AI.

**Format:** `YYYY-MM-DD - [Developer Name] - [Brief Description of Change]`

---

## Unreleased

*   2023-10-27 - [Your Name] - Initial project setup and configuration of `.cursorrules` and `changelog.md`.

```

## 6. AI-Assisted Development Workflows

The following are standard, repeatable tasks that should be performed using Cursor's AI capabilities.

### Task 1: Generating a New Next.js Component

**Goal:** Create a reusable card component for displaying Puja services. This card must adhere to our design system and be responsive.

**Procedure:**
1.  Open the chat in Cursor.
2.  Reference the rules file by typing `@.cursorrules`.
3.  Use a specific, context-rich prompt.

**Example Prompt:**

> @.cursorrules
>
> Create a new React component file at `components/puja/PujaServiceCard.tsx`.
>
> The component, named `PujaServiceCard`, should accept props for `title` (string), `description` (string), and `price` (number).
>
> Use Tailwind CSS for styling. The card should have a cream-white background (`bg-yellow-50`), a subtle shadow, and rounded corners. The title should use the primary text color, and the price should be prominent. Ensure it's responsive and supports dark mode. Use the color palette defined in the rules.

### Task 2: Creating a Backend API Endpoint

**Goal:** Create an API endpoint to handle Puja Sponsorship form submissions.

**Procedure:**
1.  Reference the relevant files, like the Prisma schema and the rules file.
2.  Instruct the AI to create a new route handler file.
3.  Specify the exact logic: parse the request, validate data, interact with the database via Prisma, and send a response.

**Example Prompt:**

> @.cursorrules @/prisma/schema.prisma
>
> Create a new Next.js API route at `app/api/sponsorships/route.ts`.
>
> This route should handle POST requests to create a new Puja Sponsorship.
>
> The function should:
> 1. Parse the incoming JSON body, which will contain `devoteeName`, `email`, `pujaId`, and `sponsorshipDate`.
> 2. Validate the incoming data. Ensure `email` is a valid email format.
> 3. Use Prisma Client to create a new record in the `PujaSponsorship` table.
> 4. Implement a `try...catch` block for robust error handling.
> 5. On success, return a JSON response with a 201 status and the created record.
> 6. On error, return a JSON response with a 500 status and an error message.

### Task 3: Refactoring for Code Quality

**Goal:** Add comprehensive JSDoc comments to an existing function to improve maintainability.

**Procedure:**
1.  Highlight the function you want to document in your editor.
2.  Open the chat or use the inline "Edit" command (Cmd+K).
3.  Provide a simple, direct instruction.

**Example Prompt:**

> Generate a complete JSDoc comment block for the selected function. Explain its purpose, each parameter, and what it returns.

### Task 4: Debugging with AI

**Goal:** An API endpoint is failing silently. Use the AI to find the root cause.

**Procedure:**
1.  Navigate to the problematic code file.
2.  In the chat, use Cursor's "Debug" terminal or provide the error message and relevant code.
3.  Reference related files that might be involved.

**Example Prompt:**

> @/app/api/donations/route.ts @/lib/stripe.ts
>
> The API endpoint in `donations/route.ts` is returning a 500 error when I try to create a Stripe checkout session, but the logs are not showing anything useful. Here is the code from the route. Can you identify potential issues and suggest a fix with more detailed logging?

## 7. File Structure for Optimal AI Context

A well-organized file structure is critical for enabling the AI to find relevant context. The AI's `@` referencing feature works best with a logical and predictable hierarchy.

*   **Components:** All reusable React components go in `/components`.
    *   **UI Primitives:** `/components/ui/` (e.g., `Button.tsx`, `Input.tsx`, `Card.tsx`). These should be generic.
    *   **Feature-Specific:** `/components/[feature]/` (e.g., `/components/events/EventCalendar.tsx`, `/components/layout/Navbar.tsx`).
*   **API Routes:** All backend API logic resides in `/app/api/`.
    *   Follow RESTful conventions: `/app/api/users/[id]/route.ts`.
*   **Library/Utilities:** Global helper functions and third-party client initializations go in `/lib/`.
    *   Example: `/lib/prisma.ts` (for instantiating the Prisma client), `/lib/utils.ts` (for shared utility functions like formatting dates).
*   **Prisma:** Keep the schema at the root: `/prisma/schema.prisma`.
*   **Public Assets:** Static assets like images, logos, and PDFs go in the `/public` directory.

By following this structure, you can easily point the AI to `@/components/ui/Button.tsx` or `@/lib/prisma.ts` to give it precise, relevant context for any task.